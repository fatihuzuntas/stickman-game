<!doctype html>
<html lang="tr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Stickman - Canvas Demo</title>
    <style>
      /* Full screen, no scroll, disable scrolling on touch */
      html, body {
        height: 100%;
        margin: 0;
        background: #111;
        color: #eee;
        -webkit-user-select: none;
        user-select: none;
        touch-action: none;
        overscroll-behavior: none;
      }

      /* Canvas full screen; CSS size logical pixels, real pixel canvas JS will set */
      canvas#game {
        display: block;
        width: 100vw;
        height: 100vh;
        outline: none;
        cursor: default;
      }

      /* Optional: pause label */
      .hud {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        display: flex;
        justify-content: center;
        padding: 10px 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        font-size: 14px;
        pointer-events: none;
        text-shadow: 0 1px 2px rgba(0,0,0,.6);
      }

      /* Simple control panel */
      .panel {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        background: rgba(18,18,18,.9);
        border: 1px solid rgba(255,255,255,.12);
        border-radius: 12px;
        padding: 14px;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        font-size: 13px;
        color: #eee;
        backdrop-filter: blur(8px);
        box-shadow: 0 12px 32px rgba(0,0,0,.5);
      }
      .panel label { display: grid; gap: 6px; }
      .panel input[type="file"] { color: #ddd; }
      .tabs { display: flex; gap: 6px; flex-wrap: wrap; }
      .tabs button { cursor: pointer; padding: 4px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.08); color: #eee; }
      .tabs button.active { background: rgba(0,255,255,.15); border-color: rgba(0,255,255,.5); }
      .tab-body { min-width: 420px; max-width: 840px; display: grid; gap: 10px; max-height: 70vh; overflow: auto; }
      .row { display: grid; grid-template-columns: 1fr auto; gap: 6px; align-items: center; }
      .list { display: grid; gap: 12px; max-height: 40vh; overflow: auto; padding-right: 4px; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); align-content: start; }
      .small { opacity: .8; font-size: 11px; }
      .char-card { display: grid; gap: 10px; border: 2px solid #2b2b2b; border-radius: 12px; padding: 12px; background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); box-shadow: inset 0 1px 0 rgba(255,255,255,.06), 0 4px 12px rgba(0,0,0,.2); }
      .cardHeader { display: flex; justify-content: space-between; align-items: center; }
      .btn { padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.08); color: #eee; cursor: pointer; }
      .btn.block { width: 100%; text-align: center; }
      .btn.secondary { background: rgba(0,0,0,.25); }
      .btn.danger { background: rgba(255,0,0,.1); border-color: rgba(255,0,0,.35); }
      .card-main { display: grid; grid-template-rows: auto 1fr; gap: 12px; }
      .card-controls { display: grid; gap: 8px; min-width: 180px; }
      .control-group { background: rgba(0,0,0,.15); border-radius: 8px; padding: 8px; }
      .control-group > label { font-weight: 600; font-size: 11px; text-transform: uppercase; letter-spacing: .3px; opacity: .9; margin-bottom: 4px; }
      .input-row { display: flex; gap: 6px; align-items: center; }
      .input-row input[type="color"] { width: 32px; height: 24px; border-radius: 4px; border: 1px solid rgba(255,255,255,.2); cursor: pointer; }
      .input-row input[type="file"] { font-size: 10px; flex: 1; }

      /* Floating settings button */
      .fab {
        position: fixed;
        right: 16px;
        bottom: 16px;
        width: 52px;
        height: 52px;
        border-radius: 50%;
        border: 1px solid rgba(255,255,255,.2);
        background: rgba(255,255,255,.08);
        color: #eee;
        font-size: 22px;
        cursor: pointer;
        display: grid;
        place-items: center;
        backdrop-filter: blur(6px);
        box-shadow: 0 10px 24px rgba(0,0,0,.4);
      }

      /* Modal */
      .modal { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,.45); }
      .modal.hidden { display: none; }
      .modal-dialog { width: min(92vw, 920px); max-height: 86vh; overflow: auto; border-radius: 14px; }
      .modal-actions { display: flex; justify-content: flex-end; gap: 8px; margin-top: 4px; }
      .modal-actions button { padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.08); color: #eee; cursor: pointer; }
      .emoji-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(44px, 1fr)); gap: 6px; }
      .emoji-grid button { font-size: 22px; padding: 6px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.08); color: #eee; cursor: pointer; }
      .thumb-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; }
      .thumb { position: relative; display: grid; place-items: center; width: 100%; aspect-ratio: 3/2; border-radius: 8px; overflow: hidden; border: 1px solid rgba(255,255,255,.15); cursor: pointer; background: rgba(255,255,255,.04); }
      .thumb canvas { width: 100%; height: 100%; display: block; }
      .thumb:hover { outline: 2px solid rgba(0,255,255,.35); outline-offset: 2px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/twemoji.min.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <canvas id="game" aria-label="Stickman Game Canvas"></canvas>
    <div class="hud" id="hud"></div>
    <button id="openSettings" class="fab" title="Settings">⚙️</button>
    <div id="modal" class="modal hidden" aria-modal="true" role="dialog">
      <div class="modal-dialog">
                  <div class="panel" aria-label="Controls" id="ui">
                      <div class="tabs">
              <button data-tab="game" class="active">Game</button>
              <button data-tab="chars">Characters</button>
              <button data-tab="bg">Background</button>
              <button data-tab="pages">Pages</button>
            </div>
                      <div class="tab-body" id="tab-game">
              <div class="small">Arrow keys: move selected character. Click on canvas to select character. P: pause, R: center. 1-9: character select, Z+1-9: multi-select, 0: select all. A-L: actions (dance, push-up, jump, wave, head shake, squat, run, yoga, fight).</div>
            </div>
          <div class="tab-body" id="tab-chars" style="display:none"></div>
          <div class="tab-body" id="tab-bg" style="display:none"></div>
          <div class="tab-body" id="tab-pages" style="display:none"></div>
        </div>
        <div class="modal-actions"><button id="closeModal">Close</button></div>
      </div>
    </div>
    <!-- Ekipman seçim alt modalı -->
    <div id="equipModal" class="modal hidden" aria-modal="true" role="dialog">
      <div class="modal-dialog">
        <div class="panel">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
            <strong>Select Equipment</strong>
            <button id="equipCloseTop" class="small" style="border:1px solid rgba(255,255,255,.2);border-radius:8px;background:rgba(255,255,255,.08);color:#eee;cursor:pointer;padding:4px 8px;">Close</button>
          </div>
          <div class="emoji-grid" id="equipGrid"></div>
          <div class="row"><label>Custom image</label><input id="equipFile" type="file" accept="image/*"></div>
          <div class="modal-actions"><button id="equipClose">Close</button></div>
        </div>
      </div>
    </div>

    <script>
      // =====================
      // Constants and settings
      // =====================
      const SETTINGS = {
        // Movement speed (logical px/sec)
        SPEED_PX_PER_SEC: 200,
        // Visual radius (used for simple pick/clamp based on head center)
        PLAYER_BOUNDING_RADIUS: 24,
        // Max delta-time to avoid huge steps when tab is backgrounded
        MAX_DT_SECONDS: 0.1,
        // Background source; read from assets folder
        BACKGROUND_SRC: 'assets/bg.jpg',
        // Light camera shake duration after reset
        SHAKE_DURATION_MS: 150,
        // Shake amplitude (logical px)
        SHAKE_AMPLITUDE_PX: 6,
      };

      // =====================
      // Helpers
      // =====================
      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function length(x, y) {
        return Math.hypot(x, y);
      }

      function normalize(x, y) {
        const len = length(x, y);
        if (len === 0) return { x: 0, y: 0 };
        return { x: x / len, y: y / len };
      }

      // =====================
      // Input class
      // =====================
      class Input {
        // Merges keyboard and touch directional inputs
        constructor(targetElement) {
          this.target = targetElement || window;
          this.keyState = new Set();
          this.justPressed = new Set();
          this.shiftPressed = false; // Track Shift state
          // Touch/pointer directions (merge multiple contacts)
          this.pointerDirsById = new Map();
          this.activePointerIds = new Set();

          // Keyboard
          window.addEventListener('keydown', (e) => {
            // Prevent page scrolling on arrow/space
            if (e.key.startsWith('Arrow') || e.key === ' ') e.preventDefault();
            
            // Track Shift state
            if (e.key === 'Shift') this.shiftPressed = true;
            
            if (!this.keyState.has(e.key)) this.justPressed.add(e.key);
            this.keyState.add(e.key);
          }, { passive: false });
          window.addEventListener('keyup', (e) => {
            this.keyState.delete(e.key);
            if (e.key === 'Shift') this.shiftPressed = false;
          });

          // Pointer/touch: invisible four-quadrant overlay logic
          const onPointer = (type, e) => {
            // Get coordinates in canvas CSS space
            const rect = this.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const id = e.pointerId || 0; // 0 for mouse
            if (type === 'down') {
              this.activePointerIds.add(id);
              this.pointerDirsById.set(id, this._posToDirs(x, y, rect.width, rect.height));
            } else if (type === 'move') {
              // Accept only pressed pointer/mouse drag (no hover tracking)
              const isPressed = this.activePointerIds.has(id) || (e.buttons && e.buttons !== 0) || (e.pressure && e.pressure > 0);
              if (!isPressed) return;
              this.pointerDirsById.set(id, this._posToDirs(x, y, rect.width, rect.height));
            } else if (type === 'up' || type === 'cancel') {
              this.activePointerIds.delete(id);
              this.pointerDirsById.delete(id);
            }
          };

          this.target.addEventListener('pointerdown', (e) => onPointer('down', e));
          this.target.addEventListener('pointermove', (e) => onPointer('move', e));
          window.addEventListener('pointerup', (e) => onPointer('up', e));
          window.addEventListener('pointercancel', (e) => onPointer('cancel', e));
        }

        _posToDirs(x, y, w, h) {
          // Four-zone overlay: screen thirds as directional regions
          const left = x < w * 0.33;
          const right = x > w * 0.67;
          const up = y < h * 0.33;
          const down = y > h * 0.67;
          return { left, right, up, down };
        }

        consumeJustPressed(key) {
          const had = this.justPressed.has(key);
          this.justPressed.delete(key);
          return had;
        }

        // Combined direction vector (keyboard + touch)
        getDirection() {
          let dx = 0, dy = 0;
          // Keyboard
          if (this.keyState.has('ArrowLeft')) dx -= 1;
          if (this.keyState.has('ArrowRight')) dx += 1;
          if (this.keyState.has('ArrowUp')) dy -= 1;
          if (this.keyState.has('ArrowDown')) dy += 1;

          // Touch: merge any active contact directions
          let touchLeft = false, touchRight = false, touchUp = false, touchDown = false;
          for (const dirs of this.pointerDirsById.values()) {
            touchLeft = touchLeft || dirs.left;
            touchRight = touchRight || dirs.right;
            touchUp = touchUp || dirs.up;
            touchDown = touchDown || dirs.down;
          }
          if (touchLeft) dx -= 1;
          if (touchRight) dx += 1;
          if (touchUp) dy -= 1;
          if (touchDown) dy += 1;

          const n = normalize(dx, dy);
          return n;
        }
      }

      // =====================
      // Stickman (player) class
      // =====================
      class Stickman {
        constructor(x, y, headImage = null, color = '#f5f5f5', leftHand = null, rightHand = null) {
          this.x = x;
          this.y = y;
          this.headImage = headImage; // Optional PNG head image
          this.color = color;
          // Equipment (left and right hand) - image or emoji
          this.leftHand = leftHand;   // { type: 'emoji'|'image', value: '🔫'|HTMLImageElement, size: number }
          this.rightHand = rightHand; // same structure
          // Simple animation state
          this.animationElapsed = 0;
          this.animationPhase = 0; // 0..1 ping-pong phase
          this.isMoving = false;
          this.currentAction = null;
          this.actionTime = 0;
          this.actionDuration = 0;
        }

        resetTo(x, y) {
          this.x = x;
          this.y = y;
          this.animationElapsed = 0;
          this.animationPhase = 0;
          this.isMoving = false;
          this.currentAction = null;
          this.actionTime = 0;
          this.actionDuration = 0;
        }

        update(dt, input, boundsW, boundsH) {
          // Movement control – only when no action is playing
          if (!this.currentAction) {
            const dir = input.getDirection();
            const speed = SETTINGS.SPEED_PX_PER_SEC;
            const vx = dir.x * speed;
            const vy = dir.y * speed;
            this.isMoving = (vx !== 0 || vy !== 0);

            this.x += vx * dt;
            this.y += vy * dt;

            // Keep inside screen bounds
            const r = SETTINGS.PLAYER_BOUNDING_RADIUS;
            this.x = clamp(this.x, r, Math.max(r, boundsW - r));
            this.y = clamp(this.y, r, Math.max(r, boundsH - r));
          } else {
            // While performing an action, stop normal movement
            this.isMoving = false;
            this.actionTime += dt;
            
            // End the action when its duration elapses
            if (this.actionTime >= this.actionDuration) {
              this.currentAction = null;
              this.actionTime = 0;
              this.actionDuration = 0;
            }
          }

          // Animation tick
          if (this.currentAction) {
            // Action animation
            const animSpeed = this.currentAction.animSpeed;
            this.animationElapsed += dt * animSpeed;
          } else if (this.isMoving) {
            // Walk animation advances only while moving
            const animSpeed = 6;
            this.animationElapsed += dt * animSpeed;
          }
          // 0..1 ping-pong phase
          const t = this.animationElapsed % 2; // 0..2
          this.animationPhase = t < 1 ? t : (2 - t);
        }

        draw(ctx) {
          // Render stickman (head, torso, arms, legs)
          ctx.save();

          // Base measures
          let headRadius = 14;
          let bodyScale = 1;
          let limbScale = 1;
          let torsoAngle = 0;     // Torso tilt (radians)
          let headAngle = 0;      // Head tilt (radians)
          let yOffset = 0;        // Vertical offset for the whole body
          
          // Convert animation phase to swing angle
          let swing = 0.9 * (this.animationPhase * 2 - 1); // -amp..+amp
          
          // Action-dependent torso/head/offset adjustments (more semantic motions)
          if (this.currentAction) {
            const actionPhase = this.animationPhase;
            switch (this.currentAction.name) {
              case 'cheer':
                // Arms up/down, subtle hop
                swing = 1.6 * Math.sin(actionPhase * Math.PI * 2);
                torsoAngle = 0.08 * Math.sin(actionPhase * Math.PI * 2);
                headAngle = -0.06 * Math.sin(actionPhase * Math.PI * 2);
                yOffset = -4 * Math.abs(Math.sin(actionPhase * Math.PI));
                break;
              case 'work':
                // Lean forward like desk work, small arm swings
                swing = 0.6 * Math.sin(actionPhase * Math.PI * 2);
                torsoAngle = 0.25;
                headAngle = -0.12;
                yOffset = 2 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'jump':
                swing = 1.2 * Math.sin(actionPhase * Math.PI * 2);
                yOffset = -14 * Math.abs(Math.sin(actionPhase * Math.PI));
                torsoAngle = 0.06 * Math.sin(actionPhase * Math.PI * 2);
                headAngle = -torsoAngle * 0.5;
                bodyScale = 1.0;
                break;
              case 'wave':
                // Slight bow, one hand waves (arm section customizes)
                swing = 0.4 * Math.sin(actionPhase * Math.PI * 2);
                torsoAngle = 0.08;
                headAngle = -0.04;
                break;
              case 'fear':
                // Arms up, torso/head recoil
                swing = 0;
                torsoAngle = -0.15 * Math.sin(actionPhase * Math.PI * 4);
                headAngle = 0.1 * Math.sin(actionPhase * Math.PI * 4);
                yOffset = -2 * Math.abs(Math.sin(actionPhase * Math.PI * 2));
                break;
              case 'crouch':
                swing = 0.8 * Math.sin(actionPhase * Math.PI * 2);
                yOffset = 10 * Math.abs(Math.sin(actionPhase * Math.PI));
                bodyScale = 0.88;
                torsoAngle = 0.04 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'run':
                swing = 1.8 * Math.sin(actionPhase * Math.PI * 3.5);
                torsoAngle = 0.1 * Math.sin(actionPhase * Math.PI * 2);
                headAngle = -torsoAngle * 0.5;
                break;
              case 'sleep':
                // Head tilts sideways, minimal swing
                swing = 0.2 * Math.sin(actionPhase * Math.PI * 1.2);
                torsoAngle = 0.05 * Math.sin(actionPhase * Math.PI * 0.8);
                headAngle = 0.35 * Math.sin(actionPhase * Math.PI * 0.8);
                yOffset = 2;
                break;
              case 'fight':
                swing = 2.2 * Math.sin(actionPhase * Math.PI * 6);
                torsoAngle = 0.12 * Math.sin(actionPhase * Math.PI * 4);
                headAngle = -0.08 * Math.sin(actionPhase * Math.PI * 4);
                break;
              case 'sit':
                // Pose: low torso, bent legs, arms slightly forward
                swing = 0;
                yOffset = 12;
                bodyScale = 0.9;
                torsoAngle = 0.03;
                headAngle = -0.03;
                break;
            }
          } else if (this.isMoving) {
            // Gentle walk sway while moving
            torsoAngle = 0.06 * Math.sin(this.animationPhase * Math.PI * 2);
            headAngle = -0.04 * Math.sin(this.animationPhase * Math.PI * 2);
            yOffset = 1.5 * Math.sin(this.animationPhase * Math.PI * 4);
          }

          const bodyLen = 30 * bodyScale;
          const limbLen = 24 * limbScale;

          // Transform: apply vertical offset and torso rotation
          ctx.translate(this.x, this.y + yOffset);
          ctx.rotate(torsoAngle);

          ctx.lineCap = 'round';
          ctx.lineWidth = 3;
          ctx.strokeStyle = this.color || '#f5f5f5';

          // Head: draw PNG if available, else circle (rotates with torso)
          const headCenterY = -headRadius - 4;
          ctx.save();
          ctx.rotate(headAngle);
          if (this.headImage && this.headImage.complete && this.headImage.naturalWidth > 0) {
            const size = headRadius * 2;
            ctx.drawImage(this.headImage, -size / 2, headCenterY - size / 2, size, size);
          } else {
            ctx.beginPath();
            ctx.arc(0, headCenterY, headRadius, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.restore();

          // Torso
          ctx.beginPath();
          ctx.moveTo(0, -4);
          ctx.lineTo(0, bodyLen);
          ctx.stroke();

          // Arms: per-action swing angles
          let armAngle, armAngleOpp;
          const shoulderY = 10;
          
          if (this.currentAction) {
            // Per-action arm angles
            const actionPhase = this.animationPhase;
            switch (this.currentAction.name) {
              case 'cheer':
                armAngle = 1.7 * Math.sin(actionPhase * Math.PI * 2);
                armAngleOpp = -1.7 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'work':
                armAngle = 0.5 * Math.sin(actionPhase * Math.PI * 2);
                armAngleOpp = -0.4 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'jump':
                armAngle = 2.5 * Math.sin(actionPhase * Math.PI * 2);
                armAngleOpp = -2.5 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'wave':
                armAngle = 2.2 * Math.sin(actionPhase * Math.PI * 3);
                armAngleOpp = 0.2;
                break;
              case 'fear':
                armAngle = 2.0;
                armAngleOpp = -2.0;
                break;
              case 'crouch':
                armAngle = 0.8 * Math.sin(actionPhase * Math.PI * 2);
                armAngleOpp = -0.8 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'run':
                armAngle = 1.6 * Math.sin(actionPhase * Math.PI * 3.5);
                armAngleOpp = -1.6 * Math.sin(actionPhase * Math.PI * 3.5);
                break;
              case 'sleep':
                armAngle = 0.3 * Math.sin(actionPhase * Math.PI * 1.2);
                armAngleOpp = 0.1 * Math.sin(actionPhase * Math.PI * 1.2);
                break;
              case 'fight':
                armAngle = 2.6 * Math.sin(actionPhase * Math.PI * 6);
                armAngleOpp = -2.6 * Math.sin(actionPhase * Math.PI * 6);
                break;
              case 'sit':
                armAngle = 0.2;
                armAngleOpp = -0.2;
                break;
              default:
                armAngle = 0.9;
                armAngleOpp = -0.9;
            }
          } else {
            // Normal movement or idle
            armAngle = this.isMoving ? swing * 0.9 : 0.9;
            armAngleOpp = this.isMoving ? -armAngle : -0.9;
          }
          
          // Compute hand positions and draw arms
          const leftHandPos = { x: Math.sin(armAngle) * limbLen, y: shoulderY + Math.cos(armAngle) * limbLen };
          const rightHandPos = { x: Math.sin(armAngleOpp) * limbLen, y: shoulderY + Math.cos(armAngleOpp) * limbLen };
          ctx.beginPath();
          ctx.moveTo(0, shoulderY);
          ctx.lineTo(leftHandPos.x, leftHandPos.y);
          ctx.moveTo(0, shoulderY);
          ctx.lineTo(rightHandPos.x, rightHandPos.y);
          ctx.stroke();

          // Legs: per-action swing angles
          let legAngle, legAngleOpp;
          
          if (this.currentAction) {
            // Per-action leg angles
            const actionPhase = this.animationPhase;
            switch (this.currentAction.name) {
              case 'cheer':
                legAngle = -0.9 * Math.sin(actionPhase * Math.PI * 2);
                legAngleOpp = 0.9 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'work':
                legAngle = 0.8;
                legAngleOpp = -0.8;
                break;
              case 'jump':
                legAngle = -1.6 * Math.sin(actionPhase * Math.PI * 2);
                legAngleOpp = 1.6 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'wave':
                legAngle = 0.9 * Math.sin(actionPhase * Math.PI * 2);
                legAngleOpp = -0.6 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'fear':
                legAngle = -1.1;
                legAngleOpp = 1.1;
                break;
              case 'crouch':
                legAngle = -1.5 * Math.sin(actionPhase * Math.PI * 2);
                legAngleOpp = 1.5 * Math.sin(actionPhase * Math.PI * 2);
                break;
              case 'run':
                legAngle = -1.9 * Math.sin(actionPhase * Math.PI * 3.5);
                legAngleOpp = 1.9 * Math.sin(actionPhase * Math.PI * 3.5);
                break;
              case 'sleep':
                legAngle = 0.4 * Math.sin(actionPhase * Math.PI * 0.8);
                legAngleOpp = -0.4 * Math.sin(actionPhase * Math.PI * 0.8);
                break;
              case 'fight':
                legAngle = -2.2 * Math.sin(actionPhase * Math.PI * 6);
                legAngleOpp = 2.2 * Math.sin(actionPhase * Math.PI * 6);
                break;
              case 'sit':
                legAngle = 1.7;
                legAngleOpp = -1.7;
                break;
              default:
                legAngle = 1.1;
                legAngleOpp = -1.1;
            }
          } else {
            // Normal movement or idle
            legAngle = this.isMoving ? -swing * 1.1 : 1.1;
            legAngleOpp = this.isMoving ? -legAngle : -1.1;
          }
          ctx.beginPath();
          ctx.moveTo(0, bodyLen);
          ctx.lineTo(Math.sin(legAngle) * limbLen, bodyLen + Math.cos(legAngle) * limbLen);
          ctx.moveTo(0, bodyLen);
          ctx.lineTo(Math.sin(legAngleOpp) * limbLen, bodyLen + Math.cos(legAngleOpp) * limbLen);
          ctx.stroke();

          // Draw equipment (hands)
          this.drawEquipment(ctx, leftHandPos, rightHandPos);

          ctx.restore();
        }

        performAction(action) {
          // If already performing an action, ignore new requests
          if (this.currentAction) return;
          
          const actions = {
            'a': { name: 'cheer',     duration: 2.2, animSpeed: 5 },
            's': { name: 'work',      duration: 3.0, animSpeed: 4 },
            'd': { name: 'jump',      duration: 1.2, animSpeed: 7 },
            'f': { name: 'wave',      duration: 1.6, animSpeed: 5 },
            'g': { name: 'fear',      duration: 2.0, animSpeed: 9 },
            'h': { name: 'crouch',    duration: 1.8, animSpeed: 3 },
            'j': { name: 'run',       duration: 2.5, animSpeed: 8 },
            'k': { name: 'sleep',     duration: 3.5, animSpeed: 1.2 },
            'l': { name: 'fight',     duration: 1.8, animSpeed: 10 },
            'o': { name: 'sit',       duration: 2.0, animSpeed: 2 }
          };
          
          if (actions[action]) {
            this.currentAction = actions[action];
            this.actionTime = 0;
            this.actionDuration = actions[action].duration;
            this.animationElapsed = 0; // Reset animation phase
          }
        }

        drawEquipment(ctx, leftPos, rightPos) {
          const drawItem = (item, pos) => {
            if (!item) return;
            const size = item.size || 22;
            if (item.type === 'emoji') {
              ctx.save();
              ctx.font = `${size}px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(item.value, pos.x, pos.y);
              ctx.restore();
            } else if (item.type === 'image' && item.value && item.value.complete) {
              ctx.drawImage(item.value, pos.x - size/2, pos.y - size/2, size, size);
            }
          };
          drawItem(this.leftHand, leftPos);
          drawItem(this.rightHand, rightPos);
        }
      }

      // =====================
      // Game class
      // =====================
      class Game {
        constructor(canvas, hudEl) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.hud = hudEl;
          this.input = new Input(canvas);
          this.dpr = Math.max(1, window.devicePixelRatio || 1);

          // Background image
          this.bgImg = new Image();
          this.bgImgLoaded = false;
          this.bgImg.addEventListener('load', () => { this.bgImgLoaded = true; });
          this.bgImg.addEventListener('error', () => { this.bgImgLoaded = false; });
          this.bgImg.src = SETTINGS.BACKGROUND_SRC;

          // Logical size (CSS px)
          this.width = 0;
          this.height = 0;

          // Camera shake
          this.shakeUntil = 0;

          // Runtime stickman list
          this.stickmen = [];
          // Multi-selection support
          this.selected = new Set();

          // State (with localStorage)
          this.state = null;
          this.lastAutosave = performance.now();

          // Game loop state
          this.paused = false;
          this.lastTime = performance.now();

          // Events
          window.addEventListener('resize', () => this.resize());
          window.addEventListener('keydown', (e) => this.onKeyDown(e));
          // Click to select stickman on canvas
          this.canvas.addEventListener('click', (e) => this.onCanvasClick(e));

          this.resize();
          this.loop = this.loop.bind(this);
          requestAnimationFrame(this.loop);
        }

        onKeyDown(e) {
          // Pause / reset controls
          if (e.key === 'p' || e.key === 'P') {
            // Use justPressed to avoid repeat storms
            if (this.input.consumeJustPressed(e.key)) {
              this.paused = !this.paused;
            }
          } else if (e.key === 'r' || e.key === 'R') {
            if (this.input.consumeJustPressed(e.key)) {
              this.resetFormation();
              this.triggerShake(SETTINGS.SHAKE_DURATION_MS);
            }
          } else if (e.key >= '1' && e.key <= '9') {
            // Number-key selection (1-9)
            const charIndex = parseInt(e.key, 10) - 1; // 1-9 -> 0-8
            if (charIndex < this.stickmen.length) {
              // Hold Z for multi-select toggle
              if (this.input.keyState.has('z') || this.input.keyState.has('Z')) {
                // Z + number: toggle in/out
                if (this.selected.has(charIndex)) {
                  this.selected.delete(charIndex);
                } else {
                  this.selected.add(charIndex);
                }
              } else {
                // Plain number: single selection
                this.selected.clear();
                this.selected.add(charIndex);
              }
            }
          } else if (e.key === '0') {
            // 0 selects all characters
            if (this.input.keyState.has('z') || this.input.keyState.has('Z')) {
              // Z + 0: clear selection
              this.selected.clear();
            } else {
              // Plain 0: select all
              this.selected.clear();
              for (let i = 0; i < this.stickmen.length; i++) {
                this.selected.add(i);
              }
            }
          } else if (e.key === 'z' || e.key === 'Z') {
            // Z clears selection immediately
            this.selected.clear();
          } else if (['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'o'].includes(e.key.toLowerCase())) {
            // Action keys – perform on selected characters
            if (this.input.consumeJustPressed(e.key)) {
              const action = e.key.toLowerCase();
              this.selected.forEach(index => {
                if (this.stickmen[index]) {
                  this.stickmen[index].performAction(action);
                }
              });
            }
          }
        }

        triggerShake(durationMs) {
          this.shakeUntil = performance.now() + durationMs;
        }

        resetFormation() {
          // Arrange around screen center in rings
          if (this.stickmen.length === 0) {
            this.stickmen.push(new Stickman(this.width / 2, this.height / 2));
          }
          const cx = this.width / 2;
          const cy = this.height / 2;
          const n = this.stickmen.length;
          const baseRadius = 20;
          for (let i = 0; i < n; i++) {
            const ring = Math.floor(i / 8);
            const angle = (i % 8) / 8 * Math.PI * 2;
            const radius = baseRadius + ring * 30;
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            this.stickmen[i].resetTo(x, y);
          }
          // Sync back to state
          this.syncPositionsToState();
          saveAppState(this.state);
        }

        onCanvasClick(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const r = SETTINGS.PLAYER_BOUNDING_RADIUS;
          let picked = -1;
          // Iterate backward to pick top-most
          for (let i = this.stickmen.length - 1; i >= 0; i--) {
            const s = this.stickmen[i];
            const dx = x - s.x;
            const dy = y - s.y;
            if (dx * dx + dy * dy <= r * r) { picked = i; break; }
          }
          if (picked !== -1) {
            if (e.ctrlKey || e.metaKey) {
              if (this.selected.has(picked)) this.selected.delete(picked); else this.selected.add(picked);
            } else {
              this.selected.clear();
              this.selected.add(picked);
            }
          }
        }

        resize() {
          // Update DPR (may change on some devices)
          const newDpr = Math.max(1, window.devicePixelRatio || 1);
          this.dpr = newDpr;

          // CSS logical size (px)
          const rect = this.canvas.getBoundingClientRect();
          this.width = Math.max(1, Math.round(rect.width));
          this.height = Math.max(1, Math.round(rect.height));

          // Backing-store (real pixel) size
          this.canvas.width = Math.round(this.width * this.dpr);
          this.canvas.height = Math.round(this.height * this.dpr);

          // Rendering quality flags
          this.ctx.imageSmoothingEnabled = true;

          // Clamp all stickmen to keep them on-screen
          const r = SETTINGS.PLAYER_BOUNDING_RADIUS;
          for (const s of this.stickmen) {
            s.x = clamp(s.x, r, Math.max(r, this.width - r));
            s.y = clamp(s.y, r, Math.max(r, this.height - r));
          }
        }

        computeShakeOffset() {
          const now = performance.now();
          if (now >= this.shakeUntil) return { x: 0, y: 0 };
          const remaining = this.shakeUntil - now;
          const t = remaining / SETTINGS.SHAKE_DURATION_MS; // 0..1
          const amp = SETTINGS.SHAKE_AMPLITUDE_PX * t; // damped
          const x = (Math.random() * 2 - 1) * amp;
          const y = (Math.random() * 2 - 1) * amp;
          return { x, y };
        }

        drawBackground() {
          // Cover fit background (preserve aspect, crop overflow)
          const { ctx, width: W, height: H } = this;
          const shake = this.computeShakeOffset();

          if (this.bgImgLoaded) {
            const iw = this.bgImg.naturalWidth;
            const ih = this.bgImg.naturalHeight;
            if (iw > 0 && ih > 0) {
              const scale = Math.max(W / iw, H / ih);
              const dw = iw * scale;
              const dh = ih * scale;
              const dx = Math.floor((W - dw) / 2 + shake.x);
              const dy = Math.floor((H - dh) / 2 + shake.y);
              ctx.drawImage(this.bgImg, dx, dy, Math.ceil(dw), Math.ceil(dh));
              return;
            }
          }
          // If not loaded, draw a simple gradient
          const g = ctx.createLinearGradient(0, 0, 0, H);
          g.addColorStop(0, '#0f2027');
          g.addColorStop(1, '#203a43');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, W, H);
        }

        loop(now) {
          const rawDt = (now - this.lastTime) / 1000;
          this.lastTime = now;
          const dt = Math.min(SETTINGS.MAX_DT_SECONDS, Math.max(0, rawDt));

          // Clear backing store, then apply DPR transform
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

          // World update
          if (!this.paused) {
            const idleInput = { getDirection: () => ({ x: 0, y: 0 }) };
            for (let i = 0; i < this.stickmen.length; i++) {
              const s = this.stickmen[i];
              const inp = (this.selected.has(i)) ? this.input : idleInput;
              s.update(dt, inp, this.width, this.height);
            }
            this.syncPositionsToState();
            // Throttle autosave
            const nowMs = performance.now();
            if (nowMs - this.lastAutosave > 600) {
              saveAppState(this.state);
              this.lastAutosave = nowMs;
            }
          }

          // Draw order: background -> characters -> HUD
          this.drawBackground();
          for (let i = 0; i < this.stickmen.length; i++) {
            const s = this.stickmen[i];
            s.draw(this.ctx);
          }

          // HUD text
          const hudText = [];
          if (this.paused) hudText.push('Paused (P)');
          hudText.push(`Stickmen: ${this.stickmen.length}`);
          hudText.push(`Selected: ${this.selected.size}`);
          hudText.push('Arrow keys: move  |  P: pause  |  R: center  |  1-9: character select  |  Z+1-9: multi-select  |  0: select all  |  A-L, O: actions (Cheer, Work, Jump, Wave, Fear, Crouch, Run, Sleep, Fight, Sit)');
          this.hud.textContent = hudText.join('   •   ');

          requestAnimationFrame(this.loop);
        }

        // ----- State integration -----
        setState(state) {
          this.state = state;
          const idx = clamp(state.currentPageIndex || 0, 0, Math.max(0, state.pages.length - 1));
          this.setPageIndex(idx);
        }

        setPageIndex(index) {
          if (!this.state) return;
          this.state.currentPageIndex = clamp(index, 0, Math.max(0, this.state.pages.length - 1));
          this.loadCurrentPage();
          saveAppState(this.state);
        }

        loadCurrentPage() {
          const page = this.getCurrentPage();
          if (!page) return;
          // Arka plan
          this.loadBgFromPage(page);
          // Karakterler
          this.stickmen = page.stickmen.map((c) => new Stickman(
            c.x ?? this.width / 2,
            c.y ?? this.height / 2,
            imageFromDataUrl(c.headImageDataUrl),
            c.color || '#f5f5f5',
            normalizeEquipment(c.leftHand),
            normalizeEquipment(c.rightHand)
          ));
          // If all are at (0,0), apply formation
          const allZero = page.stickmen.every(c => (!c.x && !c.y));
          if (allZero) {
            this.resetFormation();
          }
          this.selected.clear();
          if (this.stickmen.length > 0) this.selected.add(0);
        }

        getCurrentPage() {
          if (!this.state || !this.state.pages || this.state.pages.length === 0) return null;
          return this.state.pages[this.state.currentPageIndex] || this.state.pages[0];
        }

        syncPositionsToState() {
          const page = this.getCurrentPage();
          if (!page) return;
          for (let i = 0; i < this.stickmen.length; i++) {
            const c = page.stickmen[i];
            c.x = this.stickmen[i].x;
            c.y = this.stickmen[i].y;
            // Equipment state sync (doesn't change during render but for safety)
            c.leftHand = serializeEquipment(this.stickmen[i].leftHand);
            c.rightHand = serializeEquipment(this.stickmen[i].rightHand);
          }
        }

        loadBgFromPage(page) {
          const src = page.bgImageDataUrl || SETTINGS.BACKGROUND_SRC;
          if (this.bgImg.src === src) return;
          this.bgImgLoaded = false;
          this.bgImg = new Image();
          this.bgImg.addEventListener('load', () => { this.bgImgLoaded = true; });
          this.bgImg.addEventListener('error', () => { this.bgImgLoaded = false; });
          this.bgImg.src = src;
        }
      }

      // ====== LocalStorage state management ======
      const STORAGE_KEY = 'stickman_demo_state_v1';

      function loadAppState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return null;
          const data = JSON.parse(raw);
          if (!data || !Array.isArray(data.pages)) return null;
          return data;
        } catch (_) { return null; }
      }

      function saveAppState(state) {
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (_) {}
      }

      function defaultState() {
        return {
          currentPageIndex: 0,
          pages: [ defaultPage('Page 1') ]
        };
      }

      function defaultPage(name) {
        return {
          id: 'page-' + Math.random().toString(36).slice(2, 8),
          name: name || 'Page',
          bgImageDataUrl: null,
          stickmen: [ defaultCharacter() ],
        };
      }

      function defaultCharacter() {
        return { x: 0, y: 0, color: '#f5f5f5', headImageDataUrl: null, leftHand: null, rightHand: null };
      }

      function imageFromDataUrl(dataUrl) {
        if (!dataUrl) return null;
        const img = new Image();
        img.src = dataUrl;
        return img;
      }

      function normalizeEquipment(e) {
        if (!e) return null;
        if (e.type === 'emoji' && typeof e.value === 'string') {
          return { type: 'emoji', value: e.value, size: Math.max(12, Math.min(64, e.size || 22)) };
        }
        if (e.type === 'image' && typeof e.value === 'string') {
          const img = imageFromDataUrl(e.value);
          return { type: 'image', value: img, size: Math.max(12, Math.min(96, e.size || 22)) };
        }
        return null;
      }

      function serializeEquipment(e) {
        if (!e) return null;
        if (e.type === 'emoji') return { type: 'emoji', value: e.value, size: e.size };
        if (e.type === 'image') return { type: 'image', value: e.value.src || null, size: e.size };
        return null;
      }

      // =====================
      // Bootstrap
      // =====================
      (function main(){
        const canvas = document.getElementById('game');
        const hud = document.getElementById('hud');
        const ui = document.getElementById('ui');
        // Focus the canvas so arrow keys work immediately
        canvas.tabIndex = 0;
        canvas.focus({ preventScroll: true });
        // Create game instance
        const game = new Game(canvas, hud);

        // Load/create state and attach to game
        const loaded = loadAppState();
        const state = loaded || defaultState();
        game.setState(state);
        saveAppState(state);

        // Modal open/close
        const modal = document.getElementById('modal');
        const openSettings = document.getElementById('openSettings');
        const closeModal = document.getElementById('closeModal');
        function setModalVisible(v){ modal.classList.toggle('hidden', !v); }
        openSettings.addEventListener('click', (e)=>{ e.stopPropagation(); setModalVisible(true); });
        closeModal.addEventListener('click', (e)=>{ e.stopPropagation(); setModalVisible(false); });
        modal.addEventListener('click', (e)=>{ if (e.target === modal) setModalVisible(false); });

        // Equipment modal
        const equipModal = document.getElementById('equipModal');
        const equipGrid = document.getElementById('equipGrid');
        const equipClose = document.getElementById('equipClose');
        const equipCloseTop = document.getElementById('equipCloseTop');
        const equipFile = document.getElementById('equipFile');
        let equipCtx = { charIndex: 0, hand: 'left' };
        function setEquipVisible(v){ equipModal.classList.toggle('hidden', !v); }
        equipClose.addEventListener('click', ()=> setEquipVisible(false));
        equipCloseTop.addEventListener('click', ()=> setEquipVisible(false));
        equipModal.addEventListener('click', (e)=>{ if (e.target === equipModal) setEquipVisible(false); });

        function openEquipModal(charIndex, hand){
          equipCtx = { charIndex, hand };
          renderEquipGrid();
          setEquipVisible(true);
        }

        const EQUIP_EMOJIS = ['🔫','🗡️','🪓','🛡️','🎤','🎸','🥁','🎻','🎯','🧲','🪄','🧪','🪙','📢','🔦','🪁','🧰','📷'];
        function renderEquipGrid(){
          equipGrid.innerHTML = '';
          for (const em of EQUIP_EMOJIS) {
            const b = document.createElement('button');
            b.textContent = em;
            b.addEventListener('click', ()=>{
              const page = game.getCurrentPage();
              const i = equipCtx.charIndex;
              const data = { type: 'emoji', value: em, size: 22 };
              if (equipCtx.hand === 'left') page.stickmen[i].leftHand = data; else page.stickmen[i].rightHand = data;
              saveAppState(state);
              game.loadCurrentPage();
              setEquipVisible(false);
              showTab('chars');
            });
            equipGrid.appendChild(b);
          }
        }
        equipFile.addEventListener('change', ()=>{
          const page = game.getCurrentPage();
          const i = equipCtx.charIndex;
          const file = equipFile.files && equipFile.files[0];
          if (!file || !file.type.startsWith('image/')) return;
          const reader = new FileReader();
          reader.onload = () => {
            const dataUrl = String(reader.result);
            const data = { type: 'image', value: dataUrl, size: 28 };
            if (equipCtx.hand === 'left') page.stickmen[i].leftHand = data; else page.stickmen[i].rightHand = data;
            saveAppState(state);
            game.loadCurrentPage();
            setEquipVisible(false);
            equipFile.value = '';
            showTab('chars');
          };
          reader.readAsDataURL(file);
        });

        // UI: Tabs
        const tabs = ui.querySelectorAll('.tabs button');
        const bodies = {
          game: document.getElementById('tab-game'),
          chars: document.getElementById('tab-chars'),
          bg: document.getElementById('tab-bg'),
          pages: document.getElementById('tab-pages')
        };
        function showTab(name) {
          tabs.forEach(b => b.classList.toggle('active', b.dataset.tab === name));
          for (const k in bodies) bodies[k].style.display = (k === name ? '' : 'none');
          if (name === 'chars') renderCharsPanel();
          if (name === 'bg') renderBgPanel();
          if (name === 'pages') renderPagesPanel();
        }
        tabs.forEach(btn => btn.addEventListener('click', (e) => { e.stopPropagation(); showTab(btn.dataset.tab); }));

        // ----- Characters Panel -----
        function renderCharsPanel() {
          const panel = bodies.chars;
          const page = game.getCurrentPage();
          if (!page) { panel.innerHTML = '<div>Page not found</div>'; return; }
          const n = page.stickmen.length;
          panel.innerHTML = '';

          // Character count and editor info
          const top = document.createElement('div');
          top.className = 'row';
          top.innerHTML = `<label>Character count</label><input id="charCount" type="number" min="1" max="50" value="${n}" style="width:80px">`;
          panel.appendChild(top);
          const sub = document.createElement('div');
          sub.className = 'small';
          sub.textContent = 'Note: Editing can be done on the 1st character as an example; others share the same controls.';
          panel.appendChild(sub);
          const applyBtn = document.createElement('button');
          applyBtn.className = 'btn';
          applyBtn.textContent = 'Apply';
          panel.appendChild(applyBtn);

          // List
          const list = document.createElement('div');
          list.className = 'list';
          panel.appendChild(list);

          // Create small canvases for live previews
          const previews = [];

          for (let i = 0; i < n; i++) {
            const c = page.stickmen[i];
            const row = document.createElement('div');
            row.className = 'char-card';
            row.innerHTML = `
              <div class="cardHeader">
                <strong>Character ${i+1}</strong>
                <div style="display:flex;gap:6px;">
                  <button class="btn" data-act="select" data-i="${i}">Select</button>
                  <button class="btn secondary" data-act="multi-toggle" data-i="${i}">Ctrl</button>
                </div>
              </div>
              <div class="card-main">
                <div style="display: flex; justify-content: center;">
                  <canvas data-prev="${i}" width="160" height="140" style="background:rgba(255,255,255,.04);border-radius:8px;border:1px solid rgba(255,255,255,.1);"></canvas>
                </div>
                <div class="card-controls ${i!==0 ? 'pointer-events:none; opacity:.6;' : ''}">
                  <div class="control-group">
                    <label>Appearance</label>
                    <div class="input-row">
                      <span style="font-size:11px;opacity:.8;">Color:</span>
                      <input type="color" value="${c.color || '#f5f5f5'}" data-act="color" data-i="${i}">
                    </div>
                  </div>
                  <div class="control-group">
                    <label>Head</label>
                    <div class="input-row">
                      <input type="file" accept="image/*" data-act="head" data-i="${i}">
                    </div>
                    <div class="input-row">
                      <span class="small">${c.headImageDataUrl ? 'Loaded' : 'None'}</span>
                      <button class="btn danger" data-act="clear-head" data-i="${i}" style="font-size:10px;padding:4px 6px;">Remove</button>
                    </div>
                  </div>
                  <div class="control-group">
                    <label>Left Hand</label>
                    <div class="input-row">
                      <button class="btn" data-act="equip" data-hand="left" data-i="${i}" style="font-size:10px;padding:4px 8px;">Select</button>
                      <button class="btn secondary" data-act="equip-clear" data-hand="left" data-i="${i}" style="font-size:10px;padding:4px 8px;">Clear</button>
                    </div>
                  </div>
                  <div class="control-group">
                    <label>Right Hand</label>
                    <div class="input-row">
                      <button class="btn" data-act="equip" data-hand="right" data-i="${i}" style="font-size:10px;padding:4px 8px;">Select</button>
                      <button class="btn secondary" data-act="equip-clear" data-hand="right" data-i="${i}" style="font-size:10px;padding:4px 8px;">Clear</button>
                    </div>
                  </div>
                </div>
              </div>
            `;
            list.appendChild(row);
            previews.push(row.querySelector(`canvas[data-prev="${i}"]`));
          }

          // Draw previews: small Stickman centered in canvas
          function renderPreviews(){
            for (let i = 0; i < n; i++) {
              const c = page.stickmen[i];
              const cnv = previews[i];
              if (!cnv) continue;
              const pctx = cnv.getContext('2d');
              pctx.setTransform(1,0,0,1,0,0);
              pctx.clearRect(0,0,cnv.width,cnv.height);
              pctx.setTransform(1,0,0,1,0,0);
              const sm = new Stickman(cnv.width/2, cnv.height/2 + 10, imageFromDataUrl(c.headImageDataUrl), c.color || '#f5f5f5', normalizeEquipment(c.leftHand), normalizeEquipment(c.rightHand));
              sm.isMoving = false;
              sm.animationElapsed = 0.5; // slight pose
              sm.draw(pctx);
            }
          }
          renderPreviews();

          // Events
          applyBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const count = clamp(parseInt(panel.querySelector('#charCount').value, 10) || 1, 1, 50);
            const curr = page.stickmen.length;
            if (count > curr) {
              for (let k = curr; k < count; k++) page.stickmen.push(defaultCharacter());
            } else if (count < curr) {
              page.stickmen.length = count;
              // Fix selection set if count shrinks
              game.selected = new Set([...game.selected].filter(i => i < count));
            }
            saveAppState(state);
            game.loadCurrentPage();
            game.resetFormation();
            renderCharsPanel();
          });

          list.addEventListener('click', (e) => {
            e.stopPropagation();
            const target = e.target;
            if (!(target instanceof HTMLElement)) return;
            const i = parseInt(target.getAttribute('data-i'), 10);
            if (target.getAttribute('data-act') === 'select') {
              // Panel: single-select button (only this character)
              game.selected.clear();
              game.selected.add(i);
            } else if (target.getAttribute('data-act') === 'multi-toggle') {
              // Panel: multi-toggle (Ctrl simulation)
              if (game.selected.has(i)) game.selected.delete(i); else game.selected.add(i);
            } else if (target.getAttribute('data-act') === 'clear-head') {
              page.stickmen[i].headImageDataUrl = null;
              saveAppState(state);
              game.loadCurrentPage();
              renderCharsPanel();
            } else if (target.getAttribute('data-act') === 'equip') {
              openEquipModal(i, target.getAttribute('data-hand'));
            } else if (target.getAttribute('data-act') === 'equip-clear') {
              const hand = target.getAttribute('data-hand');
              if (hand === 'left') page.stickmen[i].leftHand = null; else page.stickmen[i].rightHand = null;
              saveAppState(state);
              game.loadCurrentPage();
              renderCharsPanel();
            }
          });

          list.addEventListener('change', (e) => {
            e.stopPropagation();
            const target = e.target;
            if (!(target instanceof HTMLElement)) return;
            const i = parseInt(target.getAttribute('data-i'), 10);
            const act = target.getAttribute('data-act');
            if (act === 'color') {
              page.stickmen[i].color = target.value;
              saveAppState(state);
              game.loadCurrentPage();
              renderPreviews();
            } else if (act === 'head') {
              const input = e.target;
              const file = input.files && input.files[0];
              if (!file || !file.type.startsWith('image/')) return;
              const reader = new FileReader();
              reader.onload = () => {
                page.stickmen[i].headImageDataUrl = String(reader.result);
                saveAppState(state);
                game.loadCurrentPage();
                renderPreviews();
              };
              reader.readAsDataURL(file);
              input.value = '';
            }
          });
        }

        // ----- Background Panel -----
        function renderBgPanel() {
          const panel = bodies.bg;
          const page = game.getCurrentPage();
          panel.innerHTML = '';
          const row1 = document.createElement('div');
          row1.className = 'row';
          row1.innerHTML = `<label>Load background</label><input id="bgFile" type="file" accept="image/*">`;
          const row2 = document.createElement('div');
          row2.className = 'row';
          row2.innerHTML = `<span class="small">${page.bgImageDataUrl ? 'Custom background loaded' : 'Default/Showcase'}</span><button id="bgClear">Clear</button>`;
          const thumbsTitle = document.createElement('div');
          thumbsTitle.innerHTML = '<strong>Ready Backgrounds (2D)</strong><div class="small">Stickman themed 5 options</div>';
          const thumbs = document.createElement('div');
          thumbs.className = 'thumb-grid';
          panel.appendChild(row1);
          panel.appendChild(row2);
          panel.appendChild(thumbsTitle);
          panel.appendChild(thumbs);

          row1.querySelector('#bgFile').addEventListener('change', (e) => {
            e.stopPropagation();
            const input = e.target;
            const file = input.files && input.files[0];
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = () => {
              page.bgImageDataUrl = String(reader.result);
              saveAppState(state);
              game.loadCurrentPage();
              renderBgPanel();
            };
            reader.readAsDataURL(file);
            input.value = '';
          });
          row2.querySelector('#bgClear').addEventListener('click', (e) => {
            e.stopPropagation();
            page.bgImageDataUrl = null;
            saveAppState(state);
            game.loadCurrentPage();
            renderBgPanel();
          });

          // 5 simple 2D preset backgrounds rendered via canvas (geometric)
          const PRESETS = [
            { name: 'Grid', draw: (ctx,w,h)=>{ ctx.fillStyle='#1a1a1a'; ctx.fillRect(0,0,w,h); ctx.strokeStyle='#222'; for(let x=0;x<w;x+=20){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke();} for(let y=0;y<h;y+=20){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke();} }},
            { name: 'Diagonal', draw: (ctx,w,h)=>{ ctx.fillStyle='#101316'; ctx.fillRect(0,0,w,h); ctx.strokeStyle='rgba(0,255,255,.12)'; for(let d=-h; d<w; d+=24){ ctx.beginPath(); ctx.moveTo(d,0); ctx.lineTo(d+h,h); ctx.stroke(); } }},
            { name: 'Dots', draw: (ctx,w,h)=>{ ctx.fillStyle='#0f0f12'; ctx.fillRect(0,0,w,h); ctx.fillStyle='rgba(255,255,255,.08)'; for(let y=8;y<h;y+=16){ for(let x=8;x<w;x+=16){ ctx.beginPath(); ctx.arc(x,y,1.5,0,Math.PI*2); ctx.fill(); } } }},
            { name: 'Waves', draw: (ctx,w,h)=>{ ctx.fillStyle='#0e1419'; ctx.fillRect(0,0,w,h); ctx.strokeStyle='rgba(0,180,255,.18)'; ctx.lineWidth=2; for(let y=10;y<h;y+=18){ ctx.beginPath(); for(let x=0;x<=w;x+=10){ const yy = y + Math.sin((x+y)*0.08)*3; if(x===0) ctx.moveTo(0,yy); else ctx.lineTo(x,yy); } ctx.stroke(); } }},
            { name: 'Rings', draw: (ctx,w,h)=>{ ctx.fillStyle='#131018'; ctx.fillRect(0,0,w,h); ctx.strokeStyle='rgba(255,255,0,.15)'; for(let r=10;r<Math.max(w,h);r+=20){ ctx.beginPath(); ctx.arc(w/2,h/2,r,0,Math.PI*2); ctx.stroke(); } }}
          ];

          PRESETS.forEach((p, idx)=>{
            const a = document.createElement('a');
            a.className = 'thumb';
            a.title = p.name;
            const cnv = document.createElement('canvas');
            cnv.width = 240; cnv.height = 160;
            const c = cnv.getContext('2d');
            p.draw(c, cnv.width, cnv.height);
            a.appendChild(cnv);
            a.addEventListener('click', (ev)=>{
              ev.preventDefault();
              // Convert canvas to Data URL and set as page background
              try {
                page.bgImageDataUrl = cnv.toDataURL('image/png');
                saveAppState(state);
                game.loadCurrentPage();
                renderBgPanel();
              } catch(_) {
                // Fallback: still store data URL
                page.bgImageDataUrl = cnv.toDataURL();
                saveAppState(state);
                game.loadCurrentPage();
                renderBgPanel();
              }
            });
            thumbs.appendChild(a);
          });
        }

        // ----- Pages Panel -----
        function renderPagesPanel() {
          const panel = bodies.pages;
          panel.innerHTML = '';
          const list = document.createElement('div');
          list.className = 'list';
          panel.appendChild(list);

          state.pages.forEach((p, i) => {
            const item = document.createElement('div');
            item.style.border = '1px solid rgba(255,255,255,.15)';
            item.style.borderRadius = '6px';
            item.style.padding = '6px';
            item.innerHTML = `
              <div class="row"><label>Name</label><input type="text" value="${p.name}"><button data-act="sel" data-i="${i}">${i===state.currentPageIndex?'Active':'Select'}</button></div>
              <div class="row"><span class="small">Characters: ${p.stickmen.length}</span><button data-act="del" data-i="${i}">Delete</button></div>
            `;
            // Page rename handler
            item.querySelector('input').addEventListener('input', (e) => {
              p.name = e.target.value;
              saveAppState(state);
            });
            list.appendChild(item);
          });

          const actions = document.createElement('div');
          actions.className = 'row';
          const addBtn = document.createElement('button');
          addBtn.textContent = 'New Page';
          actions.appendChild(document.createElement('div'));
          actions.appendChild(addBtn);
          panel.appendChild(actions);

          list.addEventListener('click', (e) => {
            e.stopPropagation();
            const t = e.target;
            if (!(t instanceof HTMLElement)) return;
            const i = parseInt(t.getAttribute('data-i'), 10);
            const act = t.getAttribute('data-act');
            if (act === 'sel') {
              game.setPageIndex(i);
              renderPagesPanel();
            } else if (act === 'del') {
              if (state.pages.length <= 1) return;
              state.pages.splice(i, 1);
              if (state.currentPageIndex >= state.pages.length) state.currentPageIndex = state.pages.length - 1;
              saveAppState(state);
              game.setPageIndex(state.currentPageIndex);
              renderPagesPanel();
            }
          });

          addBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            state.pages.push(defaultPage('New Page'));
            saveAppState(state);
            game.setPageIndex(state.pages.length - 1);
            renderPagesPanel();
          });
        }

        // Initialize with Game tab visible
        showTab('game');
      })();
    </script>
  </body>
  </html>


